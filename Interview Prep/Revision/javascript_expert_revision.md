# üü¶ JavaScript Expert-Level Revision Handbook

## üìë Table of Contents

- [Closures, Scope, Hoisting, `this`, Prototypes, Event Loop](#-closures-scope-hoisting-this-prototypes-event-loop)
- [Asynchronous JavaScript](#-asynchronous-javascript)
- [Advanced Objects & Memory](#-advanced-objects--memory)
- [Advanced Functions & ES6+ Features](#-advanced-functions--es6-features)
- [Browser & DOM Fundamentals](#-browser--dom-fundamentals)
- [Performance & Optimization](#-performance--optimization)
- [Advanced Types & Equality](#-advanced-types--equality)
- [Error Handling & Debugging](#-error-handling--debugging)
- [Concurrency & Parallelism](#-concurrency--parallelism)
- [ESNext & Modern Features](#-esnext--modern-features)
- [Patterns & Architecture in JavaScript](#-patterns--architecture-in-javascript)

---

# üü¶ Part 1 

This section covers **Closures, Scope & Hoisting, `this`, Prototypes, and the Event Loop** ‚Äî the foundation of almost every frontend interview.

---

## 1. üîí Closures

**Definition:**
A closure is a function that retains access to its **lexical environment** (scope chain) even after the outer function has finished executing.

### ‚úÖ Key Points

* JavaScript uses **lexical scoping**, not dynamic scoping.
* Closures are formed naturally whenever a function is defined inside another.
* Enable **data privacy, currying, memoization, event handlers**.

### ‚ö†Ô∏è Gotchas

* **Loop with `var`:**

  ```js
  for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);
  }
  // 3, 3, 3 (same var captured)
  ```

  Fix with `let` (block-scoped) or IIFE.

* **Memory leaks:**
  Closures capturing large objects (like DOM nodes) can prevent garbage collection.

* **Debugging pain:**
  DevTools may show ‚Äúunexpected‚Äù retained variables due to closures.

### üí° Real-world Bug

```js
function registerHandlers(nodes) {
  for (var i = 0; i < nodes.length; i++) {
    nodes[i].onclick = () => console.log("Clicked:", i);
  }
}
// All handlers print last index!
```

### üéØ Interview One-Liner

> ‚ÄúA closure is a function with its lexical scope bundled in. It enables encapsulation and callbacks but can cause bugs with loops (`var`) and memory leaks if you capture more than needed.‚Äù

---

## 2. üì¶ Scope & Hoisting

**Definition:**
Scope defines where variables are accessible. **Hoisting** means declarations are moved to the top of their scope during compilation.

### ‚úÖ Key Points

* `var` ‚Üí **function-scoped**, hoisted & initialized as `undefined`.
* `let`/`const` ‚Üí **block-scoped**, hoisted but uninitialized (**Temporal Dead Zone, TDZ**).
* Function declarations ‚Üí fully hoisted with body.
* Function expressions ‚Üí behave like variables.

### ‚ö†Ô∏è Gotchas

* **TDZ Example:**

  ```js
  console.log(x); // ReferenceError
  let x = 10;
  ```
* **Function in block scope:**

  ```js
  if (true) {
    function foo() {}
  }
  foo(); // Works differently in strict vs sloppy mode
  ```
* **Shadowing:**

  ```js
  let x = 1;
  {
    let x = 2;
    console.log(x); // 2 (outer x hidden)
  }
  ```

### üîÑ Quick Table

| Keyword  | Scope    | Hoisting        | Default Init |
| -------- | -------- | --------------- | ------------ |
| `var`    | Function | Yes             | `undefined`  |
| `let`    | Block    | Yes             | TDZ (error)  |
| `const`  | Block    | Yes             | TDZ (error)  |
| Function | Function | Yes (with body) | -            |

### üéØ Interview One-Liner

> ‚ÄúDeclarations are hoisted. `var` hoists with `undefined`; `let`/`const` hoist into the TDZ; functions hoist with their body. That‚Äôs why accessing a `let` before declaration throws, while `var` gives undefined.‚Äù

---

## 3. üß≠ The `this` Keyword

**Definition:**
`this` is determined by the **call site**, not the definition.

### ‚úÖ Rules of `this` Binding (Precedence)

1. **new binding** ‚Üí `new Foo()`
2. **explicit binding** ‚Üí `call`, `apply`, `bind`
3. **implicit binding** ‚Üí `obj.method()`
4. **default binding** ‚Üí global (window) or `undefined` (strict mode)

### ‚ö†Ô∏è Gotchas

* **Losing context:**

  ```js
  const obj = { x: 10, f() { console.log(this.x); } };
  setTimeout(obj.f, 0); // undefined (lost `this`)
  ```
* **Arrow functions:** capture lexical `this`, cannot be rebound.
* **bind + call combo:**

  ```js
  function f() { console.log(this.x); }
  const bound = f.bind({ x: 1 });
  bound.call({ x: 2 }); // still 1 (bind wins)
  ```

### üîÑ Quick Table

| Call Type              | `this` Value  |
| ---------------------- | ------------- |
| Global fn (non-strict) | `window`      |
| Global fn (strict)     | `undefined`   |
| Method call `obj.fn()` | `obj`         |
| `new Fn()`             | New instance  |
| Bound fn               | Bound object  |
| Arrow fn               | Lexical scope |

### üéØ Interview One-Liner

> ‚Äú`this` is set at call time, not definition. Precedence is: `new` > explicit (`bind`) > implicit (object call) > default (global/undefined). Arrow functions inherit `this` lexically.‚Äù

---

## 4. üß© Prototypes & Inheritance

**Definition:**
Objects inherit properties via the **prototype chain** (`[[Prototype]]`).

### ‚úÖ Key Points

* `Object.create(proto)` ‚Üí creates object with `proto` as prototype.
* Functions have a `.prototype` used when called with `new`.
* Property lookup climbs prototype chain.

### ‚ö†Ô∏è Gotchas

* Modifying `.prototype` after instances exist ‚Üí they won‚Äôt see changes.
* Shadowing: own property hides prototype property.
* Deep prototype chains slow lookups.

### Code Example

```js
function Animal(name) { this.name = name; }
Animal.prototype.speak = function() { console.log(this.name + " makes noise"); }

const dog = new Animal("Rex");
dog.speak(); // "Rex makes noise"

console.log(dog.__proto__ === Animal.prototype); // true
```

### üéØ Interview One-Liner

> ‚ÄúObjects inherit via prototypes. If a property isn‚Äôt found, JS looks up the chain. Constructors set their `.prototype` as the prototype of new instances.‚Äù

---

## 5. ‚è≥ Event Loop & Concurrency

**Definition:**
The event loop coordinates execution: it runs the **call stack**, then processes the **task queues** (macrotasks and microtasks).

### ‚úÖ Key Points

* **Macrotasks:** setTimeout, setInterval, I/O.
* **Microtasks:** Promises, MutationObserver, queueMicrotask.
* After each macrotask, the loop drains **all microtasks**.

### ‚ö†Ô∏è Gotchas

* `setTimeout(fn, 0)` is **not immediate** ‚Äî runs after microtasks.
* `Promise.then` always executes before timeouts.
* In Node.js, `process.nextTick` runs before microtasks.
* Nested promises keep chaining microtasks ‚Üí possible starvation.

### Code Example

```js
console.log("A");

setTimeout(() => console.log("B"), 0);

Promise.resolve().then(() => console.log("C"));

console.log("D");

// Output: A, D, C, B
```

### üîÑ Execution Order

1. Run **call stack**
2. Drain **microtask queue**
3. Run next **macrotask**
4. Repeat

### üéØ Interview One-Liner

> ‚ÄúThe event loop runs stack ‚Üí microtasks ‚Üí macrotasks. That‚Äôs why `Promise.then` callbacks run before `setTimeout(fn, 0)`.‚Äù

---


# üü¶ Asynchronous JavaScript

---

## 1. ‚è±Ô∏è Timers (`setTimeout`, `setInterval`)

**Definition:**
`setTimeout(fn, delay)` schedules a function once after delay; `setInterval(fn, delay)` repeats at intervals.

### ‚úÖ Key Points

* Actual delay is **minimum** ‚Äî not guaranteed exact.
* Nested timers can be throttled by browsers (clamp to ‚â•4ms after many calls, 1000ms when tab inactive).
* `clearTimeout` / `clearInterval` cancel scheduled tasks.

### ‚ö†Ô∏è Gotchas

* `setTimeout(fn, 0)` runs **after all microtasks** (not immediate).
* Long-running tasks block timers (since JS is single-threaded).
* `setInterval` can drift ‚Üí better to use recursive `setTimeout` for accuracy.

### Example

```js
setTimeout(() => console.log("timeout"), 0);
Promise.resolve().then(() => console.log("promise"));
// Output: promise, timeout
```

### üéØ Interview One-Liner

> ‚ÄúTimers schedule macrotasks. `setTimeout(fn, 0)` isn‚Äôt immediate ‚Äî it runs after microtasks. For precise intervals, recursive `setTimeout` is safer than `setInterval`.‚Äù

---

## 2. üîó Promises

**Definition:**
A Promise is an object representing the eventual result of an async operation.

### ‚úÖ Key Points

* States: **pending ‚Üí fulfilled** (resolved) / **rejected**.
* `.then` and `.catch` return new promises ‚Üí enable chaining.
* Handlers are always async (enqueued as **microtasks**).

### ‚ö†Ô∏è Gotchas

* **Unhandled rejection:**

  ```js
  Promise.reject("err");
  // Without .catch ‚Üí unhandled rejection warning
  ```
* `.then` handlers always async:

  ```js
  Promise.resolve().then(() => console.log("then"));
  console.log("sync");
  // sync, then
  ```
* Multiple `.then` on the same promise all execute independently.
* Returning a promise inside `.then` flattens it (automatic chaining).

### Example

```js
Promise.resolve(1)
  .then(x => x + 1)
  .then(x => Promise.resolve(x + 1))
  .then(console.log); // 3
```

### üéØ Interview One-Liner

> ‚ÄúPromises represent async results. `.then` handlers are always microtasks, so they run before timers. Returning a promise in `.then` flattens the chain.‚Äù

---

## 3. ‚ö° `async` / `await`

**Definition:**
Syntactic sugar over promises. `async` functions return promises; `await` pauses until promise settles.

### ‚úÖ Key Points

* `await` only works inside `async` functions (or top-level in modules).
* Execution is split ‚Üí code after `await` runs in a **microtask**.
* Parallelize with `Promise.all` to avoid serial awaits.

### ‚ö†Ô∏è Gotchas

* `await` inside loops ‚Üí serial execution (slow).

  ```js
  for (const u of users) {
    await fetch(u); // slow
  }
  await Promise.all(users.map(u => fetch(u))); // fast
  ```
* `try/catch` is needed ‚Äî `await` throws on rejection.
* Mixing `await` with non-promises just wraps in `Promise.resolve`.

### Example

```js
async function f() {
  console.log("A");
  await Promise.resolve();
  console.log("B");
}
f();
console.log("C");

// Output: A, C, B
```

### üéØ Interview One-Liner

> ‚Äú`async/await` is syntax sugar over promises. `await` pauses execution and resumes in a microtask. Using it inside loops serializes calls ‚Äî use `Promise.all` for parallelism.‚Äù

---

## 4. üéõÔ∏è Generators & Async Generators

**Definition:**
Generators (`function*`) are functions that can pause and resume using `yield`. Async generators use `for await...of`.

### ‚úÖ Key Points

* Generators return an **iterator** with `.next()`.
* Useful for building custom async workflows (before promises).
* `co` library + generators ‚Üí pre-`async/await` async management.

### ‚ö†Ô∏è Gotchas

* Generators don‚Äôt manage async by themselves; must yield promises and have a runner.
* Async generators (`async function*`) combine promises with iteration.

### Example

```js
function* gen() {
  yield 1;
  yield 2;
}
const g = gen();
console.log(g.next()); // { value: 1, done: false }
```

### üéØ Interview One-Liner

> ‚ÄúGenerators pause with `yield` and resume later. They‚Äôre useful for async flow control, but in modern JS, `async/await` replaces most generator use cases.‚Äù

---

## 5. ‚è≥ Debounce & Throttle

**Definition:**
Patterns for rate-limiting function execution.

* **Debounce:** wait until no calls happen for X ms. (Good for search input).
* **Throttle:** allow one call per X ms. (Good for scroll/resize).

### Example

```js
function debounce(fn, delay) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), delay);
  };
}

function throttle(fn, delay) {
  let last = 0;
  return (...args) => {
    const now = Date.now();
    if (now - last >= delay) {
      fn(...args);
      last = now;
    }
  };
}
```

### üéØ Interview One-Liner

> ‚ÄúDebounce delays execution until events stop; throttle limits execution to once per interval. Debounce is for inputs, throttle for continuous events like scroll.‚Äù

---

## 6. üé® requestAnimationFrame (rAF)

**Definition:**
`requestAnimationFrame(callback)` schedules a callback before the next repaint (\~16.6ms at 60fps).

### ‚úÖ Key Points

* More efficient than `setTimeout` for animations.
* Pauses when tab is inactive (better for performance).
* Ideal for smooth visual updates.

### ‚ö†Ô∏è Gotchas

* Doesn‚Äôt guarantee 60fps ‚Äî depends on device refresh rate.
* Can be canceled with `cancelAnimationFrame(id)`.

### Example

```js
function animate() {
  // draw frame
  requestAnimationFrame(animate);
}
animate();
```

### üéØ Interview One-Liner

> ‚Äú`requestAnimationFrame` runs a callback before the next repaint. It‚Äôs optimized for animations and pauses in inactive tabs.‚Äù

---

## 7. üßµ Web Workers

**Definition:**
Web Workers run JS in background threads, off the main event loop.

### ‚úÖ Key Points

* Communicate via `postMessage` (structured clone).
* No DOM access inside workers.
* Good for CPU-heavy tasks.

### ‚ö†Ô∏è Gotchas

* Serialization overhead in `postMessage`.
* SharedArrayBuffer needed for true shared memory.
* Not supported in all contexts (e.g., some cross-origin iframes).

### Example

```js
// worker.js
self.onmessage = e => {
  self.postMessage(e.data * 2);
};

// main.js
const worker = new Worker("worker.js");
worker.onmessage = e => console.log("Result:", e.data);
worker.postMessage(10); // Result: 20
```

### üéØ Interview One-Liner

> ‚ÄúWeb Workers move heavy computation off the main thread. They communicate via messages, but can‚Äôt access the DOM.‚Äù

---


# üü¶ Advanced Objects & Memory

---

## 1. üßπ Garbage Collection (GC)

**Definition:**
JavaScript uses **automatic garbage collection** ‚Äî freeing memory for objects that are no longer reachable.

### ‚úÖ Key Points

* **Reachability** = if an object can be accessed via a reference chain from a root (e.g. `window` or stack).
* Common GC strategy: **Mark & Sweep**.
* Circular references are fine if unreachable from root.

### ‚ö†Ô∏è Gotchas

* **Accidental leaks:**

  * Global variables (`window.leak = obj`).
  * Closures holding large structures.
  * Detached DOM nodes retained in memory.
* **Timers / event listeners:** If not cleared, they keep references alive.

### Example

```js
let el = document.getElementById("btn");
el.onclick = () => console.log("clicked");
// If `el` removed from DOM but reference stays in closure ‚Üí leak
```

### üéØ Interview One-Liner

> ‚ÄúGC frees unreachable memory. Leaks usually happen via globals, closures, or dangling DOM references, not because of circular references.‚Äù

---

## 2. üóùÔ∏è Symbols

**Definition:**
`Symbol()` creates a **unique primitive identifier**.

### ‚úÖ Key Points

* Never equal to another symbol, even with same description.
* Used for **non-colliding property keys**.
* `Symbol.for(key)` reuses a global registry symbol.
* Built-in symbols customize behavior (`Symbol.iterator`, `Symbol.toStringTag`).

### ‚ö†Ô∏è Gotchas

* `for...in` and `Object.keys` ignore symbols. Must use `Object.getOwnPropertySymbols`.
* JSON.stringify ignores symbols.

### Example

```js
const id = Symbol("id");
const obj = { [id]: 123 };
console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(id)]
```

### üéØ Interview One-Liner

> ‚ÄúSymbols are unique identifiers, often used as hidden object keys or to customize built-in behaviors. They‚Äôre ignored by JSON and normal enumeration.‚Äù

---

## 3. üóÑÔ∏è WeakMap & WeakSet

**Definition:**
Weak collections hold **weak references** to objects ‚Äî allowing GC when there are no other references.

### ‚úÖ Key Points

* **WeakMap:** keys must be objects, values arbitrary.
* **WeakSet:** stores objects, prevents duplicates.
* Entries are **not enumerable** (no `size`, no iteration).

### ‚ö†Ô∏è Gotchas

* Can‚Äôt inspect contents ‚Üí intentionally opaque.
* Useful for **private data** or **DOM element caching**.

### Example

```js
let wm = new WeakMap();
let obj = {};
wm.set(obj, "secret");

console.log(wm.get(obj)); // "secret"
obj = null; // entry auto-removed when GC runs
```

### üéØ Interview One-Liner

> ‚ÄúWeakMap/WeakSet hold weak references ‚Äî objects can be GC‚Äôd even if they‚Äôre keys. They‚Äôre ideal for caching and private data without leaks.‚Äù

---

## 4. üìù Property Descriptors

**Definition:**
Every property has a descriptor object with attributes:

* `value`
* `writable`
* `enumerable`
* `configurable`
  (or `get`/`set` for accessors).

### ‚úÖ Key Points

* `Object.defineProperty` controls property behavior.
* `enumerable` controls visibility in loops.
* `configurable` prevents deletion or redefinition.
* Non-writable prevents assignment.

### ‚ö†Ô∏è Gotchas

* Default attributes: `false` if defined via `defineProperty`.
* Freezing (`Object.freeze`) sets all `writable=false, configurable=false`.

### Example

```js
const obj = {};
Object.defineProperty(obj, "x", {
  value: 42,
  writable: false,
  enumerable: true,
  configurable: false
});
obj.x = 100; // ignored in strict mode ‚Üí TypeError
```

### üéØ Interview One-Liner

> ‚ÄúProperty descriptors let you control attributes like writable, enumerable, configurable. They‚Äôre the foundation of `Object.freeze` and getters/setters.‚Äù

---

## 5. üïµÔ∏è Proxy & Reflect

**Definition:**
`Proxy` allows you to intercept operations on objects. `Reflect` provides low-level methods that mirror default behavior.

### ‚úÖ Key Points

* Handlers (traps): `get`, `set`, `has`, `deleteProperty`, `apply`, `construct`.
* `Reflect` ensures correct forwarding (avoids reinventing default behavior).
* Used for logging, validation, virtualization, reactive systems (Vue3 uses Proxy).

### ‚ö†Ô∏è Gotchas

* Proxies can slow performance if overused.
* Can break identity expectations (`obj === proxy` is false).
* Some operations (like private fields) are not trap-able.

### Example

```js
const obj = { a: 1 };
const proxy = new Proxy(obj, {
  get(target, prop) {
    console.log("get", prop);
    return target[prop];
  }
});

console.log(proxy.a); // logs: get a ‚Üí 1
```

### üéØ Interview One-Liner

> ‚ÄúProxies wrap objects with traps for operations like get/set. `Reflect` provides the default behavior to forward calls. Proxies power modern reactivity systems.‚Äù

---

## 6. üßä Immutability Tricks

**Definition:**
JavaScript objects are mutable by default. Immutability ensures predictable state (important in React/Redux).

### ‚úÖ Key Points

* `Object.freeze` ‚Üí prevents modifications.
* `Object.seal` ‚Üí prevents adding/removing props, but can update values.
* `Object.preventExtensions` ‚Üí prevents new props, but allows edits/deletes.
* Deep immutability requires recursion or libraries (`immer`).

### ‚ö†Ô∏è Gotchas

* Freeze is **shallow** ‚Äî nested objects still mutable.
* Frozen objects are still extensible by changing prototype unless explicitly blocked.

### Example

```js
const obj = Object.freeze({ x: 1, y: { z: 2 } });
obj.x = 10; // ignored
obj.y.z = 20; // allowed (nested not frozen)
```

### üéØ Interview One-Liner

> ‚ÄúObjects are mutable by default. `freeze`/`seal`/`preventExtensions` restrict changes, but only shallowly. For deep immutability, you need recursion or libraries like Immer.‚Äù

---


# üü¶ Advanced Functions & ES6+ Features

---

## 1. üèóÔ∏è Higher-Order Functions (HOFs)

**Definition:**
Functions that either **take functions as arguments** or **return functions**.

### ‚úÖ Key Points

* Foundation of functional programming.
* Enable: `map`, `filter`, `reduce`, decorators, middleware.
* Encourage immutability + composition.

### ‚ö†Ô∏è Gotchas

* Passing non-functions ‚Üí runtime errors.
* Excessive nesting ‚Üí callback hell (before Promises/async).

### Example

```js
function withLogging(fn) {
  return (...args) => {
    console.log("Calling with", args);
    return fn(...args);
  };
}
const sum = (a, b) => a + b;
const loggedSum = withLogging(sum);
loggedSum(2, 3); // logs args ‚Üí 5
```

### üéØ Interview One-Liner

> ‚ÄúA higher-order function either takes functions as arguments or returns them. They enable abstractions like map, filter, and middleware.‚Äù

---

## 2. üé® Currying & Partial Application

**Definition:**

* **Currying:** Transforming a function `f(a, b, c)` into `f(a)(b)(c)`.
* **Partial application:** Pre-filling some arguments, returning a new function.

### ‚úÖ Key Points

* Used in FP libraries like Lodash, Ramda.
* Helps reusability and function composition.

### ‚ö†Ô∏è Gotchas

* Over-currying ‚Üí unreadable code.
* Currying ‚â† partial application (though related).

### Example

```js
const currySum = a => b => c => a + b + c;
currySum(1)(2)(3); // 6

function partial(fn, ...fixed) {
  return (...rest) => fn(...fixed, ...rest);
}
const add = (a, b) => a + b;
const add5 = partial(add, 5);
add5(10); // 15
```

### üéØ Interview One-Liner

> ‚ÄúCurrying breaks a function into unary steps (`f(a)(b)(c)`), while partial application pre-fills arguments. Both improve reusability.‚Äù

---

## 3. üì¶ Modules (ESM vs CommonJS)

**Definition:**
Modules encapsulate code into reusable files.

### ‚úÖ Key Points

* **CommonJS (CJS):** Node.js legacy (`require`, `module.exports`).
* **ES Modules (ESM):** Modern JS (`import`, `export`).
* ESM is **statically analyzable** ‚Üí enables tree-shaking.
* Default exports vs named exports.

### ‚ö†Ô∏è Gotchas

* Mixing CJS and ESM leads to quirks (`default` interop).
* ESM is always strict mode.
* Imports are hoisted (run before any other code).

### Example

```js
// utils.js
export function add(a, b) { return a + b; }
export default function subtract(a, b) { return a - b; }

// main.js
import subtract, { add } from "./utils.js";
```

### üéØ Interview One-Liner

> ‚ÄúCommonJS uses require, ES Modules use import/export. ESM is statically analyzable and supports tree-shaking, which is why modern bundlers prefer it.‚Äù

---

## 4. ‚ú® Destructuring & Spread/Rest

**Definition:**
Syntax for unpacking values into variables.

### ‚úÖ Key Points

* **Array destructuring:** `[a, b] = arr`.
* **Object destructuring:** `{ x, y } = obj`.
* **Rest:** gather leftovers.
* **Spread:** expand arrays/objects.

### ‚ö†Ô∏è Gotchas

* Nested destructuring ‚Üí `undefined` if property missing.
* Default values only apply when property is `undefined`, not `null`.

### Example

```js
const [a, b = 5] = [1];
console.log(a, b); // 1, 5

const { x, y: z } = { x: 10, y: 20 };
console.log(z); // 20

const arr = [1, 2];
const newArr = [...arr, 3]; // [1,2,3]
```

### üéØ Interview One-Liner

> ‚ÄúDestructuring unpacks arrays/objects, rest gathers leftovers, spread expands. Defaults only trigger on `undefined`, not `null`.‚Äù

---

## 5. üßæ Default, Rest, and Named Parameters

### ‚úÖ Key Points

* **Default params:**

  ```js
  function f(x = 10) { return x; }
  f(); // 10
  ```
* **Rest params:** collects extra args ‚Üí array.
* **Named params:** simulated with object destructuring.

### ‚ö†Ô∏è Gotchas

* Default params are evaluated at call time.
* Rest params differ from `arguments` (rest is real array, `arguments` is array-like).

### üéØ Interview One-Liner

> ‚ÄúDefault params evaluate at call time, rest params gather extras as a real array, and named params are simulated via object destructuring.‚Äù

---

## 6. üîÑ Iterators & Iterables

**Definition:**
An **iterator** is an object with `.next()`. An **iterable** has `[Symbol.iterator]`.

### ‚úÖ Key Points

* Iterables: arrays, strings, maps, sets.
* `for...of` loops over iterables (not plain objects).
* Custom iterables by implementing `[Symbol.iterator]`.

### ‚ö†Ô∏è Gotchas

* Plain objects aren‚Äôt iterable unless you define `[Symbol.iterator]`.
* Spread `...obj` works only if iterable defined.

### Example

```js
const iterable = {
  *[Symbol.iterator]() {
    yield 1; yield 2; yield 3;
  }
};
for (const x of iterable) console.log(x);
```

### üéØ Interview One-Liner

> ‚ÄúIterables implement `[Symbol.iterator]`, which returns an iterator with `.next()`. That‚Äôs why arrays, maps, and sets work with `for...of` and spread.‚Äù

---

## 7. üìö Map, Set, WeakMap, WeakSet

**Definition:**
Specialized collection types introduced in ES6.

### ‚úÖ Key Points

* **Map:** key-value pairs, keys can be any type.
* **Set:** unique values.
* **WeakMap/WeakSet:** only object keys, weak references (non-enumerable).

### ‚ö†Ô∏è Gotchas

* `NaN` is considered equal to itself in Set.
* Map preserves insertion order.
* WeakMap doesn‚Äôt prevent GC.

### Example

```js
const set = new Set([1, 2, 2, 3]);
console.log(set.size); // 3

const map = new Map();
map.set("a", 1).set({}, 2);
```

### üéØ Interview One-Liner

> ‚ÄúMap and Set are collections with insertion order preserved. WeakMap/WeakSet hold weak object references, useful for caching without memory leaks.‚Äù

---

## 8. üß≠ ES6+ Extras (that interviewers test)

### üîë Template Literals

```js
const name = "Alex";
console.log(`Hello ${name}`);
```

### üîë Tagged Templates

```js
function tag(strings, ...values) {
  return strings[0] + values.map(v => v.toUpperCase()).join("");
}
console.log(tag`Hi ${"alex"} and ${"bob"}`); // "Hi ALEXandBOB"
```

### üîë Optional Chaining & Nullish Coalescing

```js
obj?.prop?.nested; // avoids TypeError
val ?? "default";  // only default if null/undefined
```

### üéØ Interview One-Liner

> ‚ÄúModern JS adds quality-of-life features like template literals, optional chaining (`?.`), and nullish coalescing (`??`). These avoid common boilerplate and bugs.‚Äù

---


# üü¶ Browser & DOM Fundamentals

---

## 1. üéØ Event Delegation

**Definition:**
Attaching a **single event listener on a parent** to handle events for multiple child elements via **event bubbling**.

### ‚úÖ Key Points

* Uses **event propagation** (capture ‚Üí target ‚Üí bubble).
* Reduces memory usage (no per-child listeners).
* Works well for dynamic DOM (children added later).

### ‚ö†Ô∏è Gotchas

* `event.target` vs `event.currentTarget`:

  * `target` = actual clicked element.
  * `currentTarget` = element with listener.
* Some events **don‚Äôt bubble** (e.g., `blur`, `focus`).

### Example

```js
document.getElementById("list").addEventListener("click", e => {
  if (e.target.tagName === "LI") {
    console.log("Clicked item:", e.target.textContent);
  }
});
```

### üéØ Interview One-Liner

> ‚ÄúEvent delegation attaches a single listener on a parent and relies on bubbling. It‚Äôs efficient for many/dynamic child elements.‚Äù

---

## 2. üñºÔ∏è Reflow vs Repaint (Performance)

**Definition:**

* **Reflow (layout):** Browser recalculates element positions & sizes.
* **Repaint:** Browser redraws pixels (e.g., color change).

### ‚úÖ Key Points

* Reflow is more expensive than repaint.
* Causes of reflow: DOM changes, style changes, window resize, font load.
* Batch DOM reads/writes to avoid multiple reflows.

### ‚ö†Ô∏è Gotchas

* Accessing layout properties (`offsetHeight`, `scrollTop`) forces reflow.
* Animating `top/left` triggers layout; animating `transform/opacity` is GPU-optimized.

### Example

```js
const el = document.getElementById("box");
el.style.width = "200px";          // triggers reflow
console.log(el.offsetHeight);      // forces reflow again (expensive)
```

### üéØ Interview One-Liner

> ‚ÄúReflow recalculates layout, repaint redraws pixels. Reflow is costly ‚Äî optimize by batching DOM changes and animating transform/opacity.‚Äù

---

## 3. üå≥ DOM Traversal & Manipulation

### ‚úÖ Methods

* `getElementById`, `querySelector`, `querySelectorAll`.
* `parentNode`, `children`, `nextSibling`.
* Creating: `document.createElement`, `appendChild`, `insertBefore`.
* Performance: Use **DocumentFragment** for batch insertions.

### ‚ö†Ô∏è Gotchas

* `innerHTML` is faster for large inserts but unsafe (XSS risk).
* `NodeList` vs `HTMLCollection`:

  * `NodeList` can be static or live.
  * `HTMLCollection` is always live.

### üéØ Interview One-Liner

> ‚ÄúDOM traversal uses APIs like querySelector, parentNode, and siblings. For performance, batch inserts with DocumentFragment instead of repeated appendChild.‚Äù

---

## 4. üíæ Storage APIs

### ‚úÖ Key Points

* **Cookies:**

  * 4KB limit.
  * Sent with every HTTP request.
  * Expiration & domain/path scoped.
* **localStorage:**

  * 5‚Äì10MB.
  * Synchronous API.
  * Persistent until cleared.
* **sessionStorage:**

  * Per-tab/session.
* **IndexedDB:**

  * Async, NoSQL DB in browser.
  * Large storage, structured queries.

### ‚ö†Ô∏è Gotchas

* localStorage is **blocking** ‚Üí avoid heavy writes in main thread.
* Cookies hurt performance since they‚Äôre sent on every request.
* IndexedDB APIs are clunky (usually use wrapper libraries).

### üéØ Interview One-Liner

> ‚ÄúCookies are for server comms (small, auto-sent), localStorage/sessionStorage for small client-only data, and IndexedDB for large structured storage.‚Äù

---

## 5. üîí Browser Security (CORS, CSRF, XSS)

### ‚úÖ CORS (Cross-Origin Resource Sharing)

* Controls cross-domain requests.
* Server sets `Access-Control-Allow-Origin`.

### ‚úÖ CSRF (Cross-Site Request Forgery)

* Malicious site tricks user‚Äôs browser into sending authenticated request.
* Prevented with **CSRF tokens** or **SameSite cookies**.

### ‚úÖ XSS (Cross-Site Scripting)

* Injected scripts executed in victim‚Äôs browser.
* Prevented with **escaping, CSP (Content Security Policy)**.

### üéØ Interview One-Liner

> ‚ÄúCORS controls which origins can access resources, CSRF tricks users into sending unwanted requests, and XSS injects malicious scripts. Fix with headers, tokens, and sanitization.‚Äù

---

## 6. ‚ö° Service Workers

**Definition:**
Background scripts that intercept network requests ‚Üí enable **offline caching, push notifications, background sync**.

### ‚úÖ Key Points

* Use **Cache API** for offline storage.
* Run in their own thread (no DOM access).
* Lifecycle: install ‚Üí activate ‚Üí fetch.

### ‚ö†Ô∏è Gotchas

* Require HTTPS.
* Debugging can be tricky (stale workers ‚Üí need manual refresh).
* Misuse can cause cache-bloat or stale responses.

### Example

```js
self.addEventListener("fetch", e => {
  e.respondWith(
    caches.match(e.request).then(res => res || fetch(e.request))
  );
});
```

### üéØ Interview One-Liner

> ‚ÄúService workers are background scripts that enable offline caching and network interception. They power PWAs but must be carefully managed to avoid stale caches.‚Äù

---

## 7. üåê Critical Rendering Path (CRP)

**Definition:**
Steps the browser takes to convert HTML/CSS/JS into pixels.

### ‚úÖ Stages

1. Parse HTML ‚Üí DOM
2. Parse CSS ‚Üí CSSOM
3. Combine ‚Üí Render Tree
4. Layout (Reflow)
5. Paint (Repaint)
6. Composite layers

### ‚ö†Ô∏è Gotchas

* **Render-blocking:** CSS blocks rendering, JS blocks parsing unless `defer/async`.
* **Fonts:** FOUT/FOIT issues (Flash of Unstyled/Invisible Text).

### üéØ Interview One-Liner

> ‚ÄúThe CRP is DOM + CSSOM ‚Üí render tree ‚Üí layout ‚Üí paint ‚Üí composite. Optimize by deferring scripts, minimizing CSS, and preloading fonts.‚Äù

---

## 8. üß© Resource Loading (`async` vs `defer`)

**Definition:**
Attributes that control how scripts load.

### ‚úÖ Key Points

* `async`: downloads in parallel, executes ASAP (order not guaranteed).
* `defer`: downloads in parallel, executes **after HTML parse**, preserves order.
* Default: blocking (bad for performance).

### üéØ Interview One-Liner

> ‚ÄúUse `defer` for scripts that rely on DOM, `async` for independent scripts. Default blocking scripts delay parsing and hurt performance.‚Äù

---


# üü¶ Core JavaScript ‚Äî Expert-Level Revision

# üü¶ Performance & Optimization

---

## 1. üßπ Memory Leaks in Frontend

**Definition:**
A memory leak happens when memory is not released after it‚Äôs no longer needed.

### ‚úÖ Common Sources

* **Uncleared timers/intervals**:

  ```js
  setInterval(() => { /* ... */ }, 1000); // never cleared
  ```
* **Detached DOM nodes** kept in closures or global arrays.
* **Event listeners** not removed on unmount.
* **Global variables** and singletons that grow unbounded.

### üéØ Interview One-Liner

> ‚ÄúFrontend leaks often come from forgotten event listeners, timers, or DOM nodes retained in closures. Use cleanup (`clearInterval`, `removeEventListener`) and profiling tools.‚Äù

---

## 2. üí§ Lazy Loading & Code Splitting

**Definition:**
Splitting bundles into smaller chunks and loading them on demand.

### ‚úÖ Key Points

* Reduces initial load time.
* Implemented with **dynamic imports** (`import()`), route-based splitting.
* Use `React.lazy` + `Suspense` for components.

### ‚ö†Ô∏è Gotchas

* Too many small chunks ‚Üí overhead.
* Network latency can hurt if misconfigured.

### üéØ Interview One-Liner

> ‚ÄúLazy loading reduces initial load by splitting code into chunks. Use `import()` or `React.lazy`. Balance chunk size to avoid too many round-trips.‚Äù

---

## 3. üå≥ Tree-Shaking

**Definition:**
Removing unused code during bundling.

### ‚úÖ Key Points

* Works only with **ESM (import/export)** because it‚Äôs statically analyzable.
* Dead code elimination depends on bundler + minifier (Webpack, Rollup, Terser).

### ‚ö†Ô∏è Gotchas

* Dynamic `require()` prevents tree-shaking.
* Side-effects in modules can block elimination.

### üéØ Interview One-Liner

> ‚ÄúTree-shaking eliminates unused exports but only works with static ES modules. Avoid dynamic imports and side-effects in libraries.‚Äù

---

## 4. ‚ö° Web Vitals

**Definition:**
Google‚Äôs metrics for user-perceived performance.

### ‚úÖ Core Metrics

* **LCP (Largest Contentful Paint):** load speed (<2.5s).
* **FID (First Input Delay):** input responsiveness (<100ms).
* **CLS (Cumulative Layout Shift):** visual stability (<0.1).
* (New) **INP (Interaction to Next Paint)** replacing FID.

### üéØ Interview One-Liner

> ‚ÄúWeb Vitals measure perceived performance: LCP for load, FID/INP for input, CLS for stability. Optimize via lazy loading, preloading, and reducing JS.‚Äù

---

## 5. üßæ Async Scheduling (Idle Time)

**Definition:**
Scheduling work when the browser is idle.

### ‚úÖ Key Points

* `requestIdleCallback(cb)` ‚Üí runs when browser is idle.
* Useful for non-critical background work.
* Fallback to timers for unsupported browsers.

### ‚ö†Ô∏è Gotchas

* Not guaranteed to run (if browser never idle).
* Time budget limited (\~50ms).

### üéØ Interview One-Liner

> ‚Äú`requestIdleCallback` lets you run background work without blocking the main thread, but it may not fire on busy pages.‚Äù

---

## 6. üéØ Preload, Prefetch, DNS Prefetch

### ‚úÖ Key Points

* **Preload:** critical resources needed soon.
* **Prefetch:** resources likely needed in future navigation.
* **DNS-prefetch:** resolve domain names early.

### Example

```html
<link rel="preload" href="hero.jpg" as="image" />
<link rel="prefetch" href="/next-page.js" />
<link rel="dns-prefetch" href="//cdn.example.com" />
```

### üéØ Interview One-Liner

> ‚ÄúPreload fetches critical resources now, prefetch loads likely future ones, DNS-prefetch resolves domains early.‚Äù

---

## 7. üì¶ Bundling Strategies

* **Monolithic bundle** ‚Üí fast for small apps, bad for scale.
* **Code-splitting** ‚Üí route-level chunks.
* **Micro-frontends** ‚Üí separate bundles per domain (federation).
* **CDN caching** ‚Üí cache chunks by content hash.

### üéØ Interview One-Liner

> ‚ÄúBundle strategy depends on scale. Use route-based code splitting, cache chunks with hashes, and avoid giant monolithic bundles.‚Äù

---

## 8. üèéÔ∏è Rendering Performance Tips

* Minimize **reflows** (batch DOM changes).
* Use **transform/opacity** for animations.
* Virtualize large lists (e.g., `react-window`).
* Debounce resize/scroll listeners.

### üéØ Interview One-Liner

> ‚ÄúReflows are expensive ‚Äî batch DOM updates, use transform/opacity for animations, and virtualize long lists.‚Äù

---


# üü¶ Core JavaScript ‚Äî Expert-Level Revision

# üü¶ Advanced Types & Equality

---

## 1. üìå Truthy & Falsy Values

**Definition:**
When converted to a boolean (e.g., in `if` conditions), some values are considered **truthy** or **falsy**.

### ‚úÖ Falsy Values (only 7!)

* `false`
* `0`, `-0`
* `""` (empty string)
* `null`
* `undefined`
* `NaN`

Everything else ‚Üí **truthy** (including `"0"`, `[]`, `{}`, `Infinity`).

### ‚ö†Ô∏è Gotchas

```js
if ("0") console.log("runs");   // runs (string "0" is truthy)
if ([]) console.log("runs");    // runs (empty array is truthy)
if ({}) console.log("runs");    // runs (empty object is truthy)
```

### üéØ Interview One-Liner

> ‚ÄúOnly 7 values are falsy: false, 0, -0, "", null, undefined, NaN. Everything else is truthy ‚Äî even empty arrays/objects.‚Äù

---

## 2. üîÑ `==` vs `===`

**Definition:**

* `===` (strict equality): no type coercion.
* `==` (loose equality): allows coercion.

### ‚úÖ Rules (selected weird ones)

```js
0 == false        // true
"" == false       // true
null == undefined // true
[] == false       // true ( [] ‚Üí "" ‚Üí 0 )
[] == ![]         // true ( [] == false )
[1] == 1          // true ([1].toString() ‚Üí "1")
[1,2] == "1,2"    // true
```

### ‚ö†Ô∏è Gotchas

* `NaN == NaN` ‚Üí false (NaN is never equal to itself).
* `null` only equals `undefined` (and itself).
* `0 == []` is true, but `0 == {}` is false.

### üéØ Interview One-Liner

> ‚Äú`===` checks value + type, no coercion. `==` coerces and has weird rules: `null == undefined` only, arrays convert to strings, and NaN never equals itself.‚Äù

---

## 3. üßæ Special Numbers: `NaN`, `Infinity`, `-0`

### ‚úÖ NaN

* Not equal to itself: `NaN === NaN` ‚Üí false.
* Use `Number.isNaN()` (better than `isNaN`).
* `isNaN("foo")` ‚Üí true (coerces to NaN).

### ‚úÖ Infinity

* `1 / 0` ‚Üí `Infinity`.
* `-1 / 0` ‚Üí `-Infinity`.

### ‚úÖ -0

* JS has **two zeros**: `0` and `-0`.
* `0 === -0` ‚Üí true.
* But `1 / 0 === Infinity`, `1 / -0 === -Infinity`.

### üéØ Interview One-Liner

> ‚ÄúJS has two zeros: +0 and -0. They compare equal with `===`, but divide by them to get ¬±Infinity. NaN is never equal to itself.‚Äù

---

## 4. üóùÔ∏è `Object.is`

**Definition:**
Like `===` but fixes edge cases:

### ‚úÖ Rules

```js
Object.is(NaN, NaN);   // true
Object.is(0, -0);      // false
Object.is(5, 5);       // true
Object.is({}, {});     // false (different refs)
```

### üéØ Interview One-Liner

> ‚Äú`Object.is` is like strict equality but distinguishes -0 and +0, and treats NaN as equal to itself.‚Äù

---

## 5. üì¶ Primitive vs Object Wrappers

**Definition:**
Primitives (`string`, `number`, `boolean`, `symbol`, `bigint`, `null`, `undefined`) have **object wrappers** for method access.

### ‚úÖ Examples

```js
"hello".toUpperCase();   // works because JS boxes into String object
new String("hello");     // object wrapper
typeof "hello";          // "string"
typeof new String("hi"); // "object"
```

### ‚ö†Ô∏è Gotchas

* `new Boolean(false)` is truthy (object is always truthy).
* Comparing primitive vs object:

```js
"hi" === new String("hi"); // false
"hi" == new String("hi");  // true (coerces)
```

### üéØ Interview One-Liner

> ‚ÄúPrimitives auto-box into wrappers (e.g., 'hi'.toUpperCase()). But wrapper objects (`new String`) are truthy and behave differently ‚Äî avoid them.‚Äù

---

## 6. üß© Typeof, instanceof, and `Array.isArray`

### ‚úÖ typeof

* `typeof null` ‚Üí `"object"` (bug since JS 1.0).
* `typeof NaN` ‚Üí `"number"`.
* `typeof function() {}` ‚Üí `"function"`.

### ‚úÖ instanceof

* Checks prototype chain.
* Works across inheritance.
* Fails across iframes (different globals).

### ‚úÖ Array.isArray

* Safest way to check arrays (cross-realm safe).

### Example

```js
[] instanceof Array;           // true
[] instanceof Object;          // true
Array.isArray([]);             // true
typeof null;                   // "object"
```

### üéØ Interview One-Liner

> ‚Äú`typeof null` is 'object' (legacy bug). `instanceof` checks prototype chains but breaks across realms. Use `Array.isArray` to check arrays safely.‚Äù

---

## 7. üßÆ Type Conversion (Explicit vs Implicit)

### ‚úÖ Explicit

* `Number("42")` ‚Üí 42
* `String(123)` ‚Üí "123"
* `Boolean(0)` ‚Üí false

### ‚úÖ Implicit (coercion)

* `1 + "2"` ‚Üí "12" (string concatenation).
* `1 - "2"` ‚Üí -1 (string ‚Üí number).
* `[] + []` ‚Üí "" (empty string).
* `[] + {}` ‚Üí "\[object Object]".
* `{} + []` ‚Üí 0 (parsed as block + array).

### ‚ö†Ô∏è Gotchas

```js
[] == ![]; // true
// [] -> "" -> 0, ![] -> false -> 0
```

### üéØ Interview One-Liner

> ‚ÄúType coercion is implicit conversion. Addition prefers strings, subtraction prefers numbers. Weird cases like \[] + {} = '\[object Object]' are from toString/valueOf conversions.‚Äù

---


# üü¶ Core JavaScript ‚Äî Expert-Level Revision

# üü¶ Error Handling & Debugging

---

## 1. ‚ö†Ô∏è `try` / `catch` / `finally`

**Definition:**
Mechanism for handling runtime exceptions.

### ‚úÖ Key Points

* `catch` handles synchronous errors in the `try` block.
* `finally` always executes (even if return/throw in try/catch).
* Errors bubble up if unhandled.

### ‚ö†Ô∏è Gotchas

```js
try {
  throw new Error("boom");
} catch (e) {
  return "handled";
} finally {
  return "finally"; // overrides catch return
}
```

### üéØ Interview One-Liner

> ‚Äú`finally` always runs and overrides return values. Errors bubble up unless caught.‚Äù

---

## 2. üï∏Ô∏è Error Types in JavaScript

### ‚úÖ Built-in Error Objects

* `Error` ‚Üí base class.
* `SyntaxError` ‚Üí invalid syntax (only at parse time).
* `ReferenceError` ‚Üí accessing undeclared variable.
* `TypeError` ‚Üí invalid operation (e.g., calling non-function).
* `RangeError` ‚Üí out-of-range numbers (e.g., invalid array length).
* `URIError` ‚Üí malformed URI in `encodeURI/decodeURI`.
* `EvalError` ‚Üí legacy, rarely used.

### Example

```js
try {
  JSON.parse("{ invalid }");
} catch (e) {
  console.log(e instanceof SyntaxError); // true
}
```

### üéØ Interview One-Liner

> ‚ÄúJS has typed errors: Syntax, Reference, Type, Range, URI. Most common in practice: TypeError and ReferenceError.‚Äù

---

## 3. üõ†Ô∏è Custom Errors

**Definition:**
Extend the `Error` class for domain-specific errors.

### Example

```js
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}
throw new ValidationError("Invalid input");
```

### üéØ Interview One-Liner

> ‚ÄúCustom errors extend Error and set a name for better debugging.‚Äù

---

## 4. ‚ö° Async Error Handling

### ‚úÖ Promises

```js
fetch("bad-url")
  .then(res => res.json())
  .catch(err => console.error("Caught:", err));
```

* `.catch()` handles errors in promise chain.
* Uncaught rejections trigger `unhandledrejection` event.

### ‚úÖ async/await

```js
async function getData() {
  try {
    await fetch("bad-url");
  } catch (err) {
    console.error("Caught:", err);
  }
}
```

* Must wrap `await` in `try/catch`.
* Rejections not caught will bubble like exceptions.

### üéØ Interview One-Liner

> ‚ÄúPromise errors bubble until caught. In async/await, use try/catch around awaits. Unhandled rejections trigger a global event.‚Äù

---

## 5. üåç Global Error Handling

### ‚úÖ Browser

```js
window.onerror = (msg, url, line, col, err) => {
  console.error("Global error:", msg, err);
};
window.onunhandledrejection = e => {
  console.error("Unhandled rejection:", e.reason);
};
```

### ‚úÖ Node.js

```js
process.on("uncaughtException", err => { ... });
process.on("unhandledRejection", err => { ... });
```

### ‚ö†Ô∏è Gotchas

* Don‚Äôt rely on global handlers as the *only* mechanism ‚Äî they‚Äôre last resort.
* Use for logging/alerting in production.

### üéØ Interview One-Liner

> ‚ÄúGlobal error handlers (`window.onerror`, `onunhandledrejection`) are safety nets ‚Äî good for logging, but not a replacement for local handling.‚Äù

---

## 6. üß≠ Debugging Techniques

### ‚úÖ Tools

* `console.*` (log, warn, error, table, dir).
* `debugger` keyword (pauses execution in DevTools).
* Source maps (map minified code to original).

### ‚úÖ Advanced

* Performance profiling (DevTools Performance tab).
* Memory profiling (heap snapshots, allocation timelines).
* Break on DOM mutation.

### üéØ Interview One-Liner

> ‚ÄúUse console, debugger, and source maps for debugging. For perf/memory, use DevTools profiling and heap snapshots.‚Äù

---

## 7. üìã Best Practices for Error Handling

* **Fail fast, fail safe** ‚Üí throw early, recover gracefully.
* Don‚Äôt swallow errors (`catch(e){}` with empty body).
* Normalize errors (consistent structure across app).
* Log with context (user action, environment).
* Avoid throwing strings, always `throw new Error(...)`.
* Separate **expected errors** (validation) from **unexpected ones** (bugs).

### üéØ Interview One-Liner

> ‚ÄúBest practice: never swallow errors, always throw Error objects, separate expected from unexpected, and log with context.‚Äù

---


# üü¶ Core JavaScript ‚Äî Expert-Level Revision

# üü¶ Concurrency & Parallelism

---

## 1. üßµ Single-Threaded Model

**Definition:**
JavaScript executes on a **single thread** (the call stack) with concurrency simulated via the **event loop**.

### ‚úÖ Key Points

* JS can‚Äôt run two functions truly in parallel on the main thread.
* Concurrency = overlapping tasks (via async callbacks).
* Parallelism = tasks literally executing at the same time (needs threads/workers).

### ‚ö†Ô∏è Gotchas

* Long-running tasks block UI ‚Üí ‚Äúfrozen page‚Äù.
* Async doesn‚Äôt mean parallel (Promises still run on one thread).

### üéØ Interview One-Liner

> ‚ÄúJavaScript is single-threaded; concurrency comes from the event loop, but real parallelism requires workers.‚Äù

---

## 2. ‚è≥ Concurrency via Event Loop

**Definition:**
The event loop interleaves tasks from macrotask & microtask queues.

### ‚úÖ Key Points

* Concurrency = cooperative multitasking.
* No two JS functions run at the same instant on the same thread.

### Example

```js
setTimeout(() => console.log("timer"), 0);
Promise.resolve().then(() => console.log("promise"));
// Output: promise, timer
```

### üéØ Interview One-Liner

> ‚ÄúConcurrency in JS is managed by the event loop ‚Äî tasks interleave but don‚Äôt run truly in parallel.‚Äù

---

## 3. ‚ö° Parallelism via Web Workers

**Definition:**
Web Workers run JS in **background threads** separate from the main UI thread.

### ‚úÖ Key Points

* Communicate via `postMessage` (structured cloning).
* No direct DOM access.
* Useful for CPU-heavy tasks.

### ‚ö†Ô∏è Gotchas

* Serialization overhead for large messages.
* No shared state by default (copy-on-message).
* Debugging workers is harder than main thread code.

### Example

```js
// worker.js
self.onmessage = e => self.postMessage(e.data * 2);

// main.js
const w = new Worker("worker.js");
w.onmessage = e => console.log(e.data);
w.postMessage(10); // 20
```

### üéØ Interview One-Liner

> ‚ÄúWeb Workers provide real parallelism by running JS in separate threads, but can‚Äôt touch the DOM and communicate only via messages.‚Äù

---

## 4. üß© SharedArrayBuffer & Atomics

**Definition:**
APIs for **shared memory** and low-level synchronization between workers.

### ‚úÖ Key Points

* `SharedArrayBuffer`: allows multiple threads to view/edit same memory.
* `Atomics`: provides atomic operations (safe increments, waits, notifications).
* Enables building locks, semaphores, and concurrent data structures in JS.

### ‚ö†Ô∏è Gotchas

* Very advanced ‚Äî rarely used directly, but underpins WebAssembly multithreading.
* Security concerns ‚Üí disabled after Spectre/Meltdown, re-enabled with stricter cross-origin isolation.

### Example

```js
const buffer = new SharedArrayBuffer(4);
const arr = new Int32Array(buffer);

Atomics.store(arr, 0, 42);
console.log(Atomics.load(arr, 0)); // 42
```

### üéØ Interview One-Liner

> ‚ÄúSharedArrayBuffer + Atomics let workers share memory and coordinate safely. It‚Äôs how JS supports real multithreading in WebAssembly.‚Äù

---

## 5. üßÆ Parallelism in Node.js

**Definition:**
Node is single-threaded per process, but offers parallelism.

### ‚úÖ Key Points

* **Worker Threads** (since Node 10.5) ‚Üí parallel JS execution.
* **Child Processes** ‚Üí true OS-level processes.
* **Cluster Module** ‚Üí multiple processes sharing load.
* **libuv threadpool** ‚Üí parallelize I/O and certain CPU tasks (crypto, fs).

### üéØ Interview One-Liner

> ‚ÄúNode achieves parallelism with worker threads, child processes, or libuv‚Äôs threadpool ‚Äî though the main JS thread is single.‚Äù

---

## 6. üèéÔ∏è Practical Uses of Parallelism

* **Image processing** in background via workers.
* **Large JSON parsing** ‚Üí offload to worker to avoid UI freeze.
* **Concurrent fetch requests** ‚Üí concurrency (not parallelism).
* **WebAssembly with threads** ‚Üí real CPU parallelism.

---


# üü¶ Core JavaScript ‚Äî Expert-Level Revision

# üü¶ ESNext & Modern Features

---

## 1. üî¢ BigInt

**Definition:**
A primitive type for arbitrarily large integers.

### ‚úÖ Key Points

* Append `n` ‚Üí `123n`.
* Can‚Äôt mix with normal `Number` without explicit conversion.
* No precision loss for huge numbers.

### ‚ö†Ô∏è Gotchas

```js
2n + 3; // TypeError (can‚Äôt mix BigInt and Number)
Number(2n) === 2; // true
```

### üéØ Interview One-Liner

> ‚ÄúBigInt represents integers beyond Number‚Äôs 2^53-1 limit. You can‚Äôt mix it with Number ‚Äî must explicitly convert.‚Äù

---

## 2. üß© Optional Chaining (`?.`)

**Definition:**
Safe property access without throwing if intermediate is null/undefined.

### ‚úÖ Key Points

* Short-circuits if value is null/undefined.
* Works with properties, function calls, array indexes.

### Example

```js
const user = {};
console.log(user.profile?.email); // undefined, not error
console.log(user.getName?.());    // undefined
```

### üéØ Interview One-Liner

> ‚ÄúOptional chaining avoids errors by short-circuiting on null/undefined. It works for props, calls, and arrays.‚Äù

---

## 3. üü∞ Nullish Coalescing (`??`)

**Definition:**
Provides a fallback only for `null`/`undefined`, not falsy values.

### ‚úÖ Key Points

```js
0 || 42;   // 42
0 ?? 42;   // 0

"" || "x"; // "x"
"" ?? "x"; // ""
```

### üéØ Interview One-Liner

> ‚Äú`??` differs from `||` by treating only null/undefined as missing. Falsy values like 0 and '' are kept.‚Äù

---

## 4. üîÑ Top-Level `await`

**Definition:**
Allows `await` at the top level of ES modules.

### ‚úÖ Key Points

* Only allowed in ES modules (`type="module"`).
* Blocks module evaluation until awaited promise resolves.

### Example

```js
// top-level-await.js
const data = await fetch("/api").then(r => r.json());
console.log(data);
```

### üéØ Interview One-Liner

> ‚ÄúTop-level await lets you use await outside functions in ES modules, pausing module execution until resolved.‚Äù

---

## 5. ‚ôªÔ∏è WeakRefs & FinalizationRegistry

**Definition:**
APIs to reference objects without preventing GC.

### ‚úÖ WeakRef

* `new WeakRef(obj)` ‚Üí creates weak reference.
* `.deref()` returns object if still alive, else undefined.

### ‚úÖ FinalizationRegistry

* Lets you run cleanup after object GC (non-deterministic).

### ‚ö†Ô∏è Gotchas

* **Unreliable for program logic** ‚Äî GC is unpredictable.
* Intended for caches, not control flow.

### Example

```js
let obj = { value: 123 };
const weak = new WeakRef(obj);

obj = null; // eligible for GC
console.log(weak.deref()); // maybe object, maybe undefined later
```

### üéØ Interview One-Liner

> ‚ÄúWeakRefs allow GC‚Äôd objects to be referenced weakly, and FinalizationRegistry lets you clean them up. Use for caches, not program logic.‚Äù

---

## 6. üìÜ Temporal API (Proposal Stage 3)

**Definition:**
New Date/Time API to replace `Date` (which is broken).

### ‚úÖ Key Points

* Immutable, time zone aware, clear APIs.
* Objects: `PlainDate`, `PlainTime`, `ZonedDateTime`, `Duration`.
* Fixes DST bugs, leap second issues.

### Example

```js
import { Temporal } from "@js-temporal/polyfill";
const today = Temporal.Now.plainDateISO();
console.log(today.add({ days: 1 }).toString());
```

### üéØ Interview One-Liner

> ‚ÄúTemporal is the modern Date/Time API: immutable, time-zone aware, and accurate. It‚Äôs the future replacement for JS Date.‚Äù

---

## 7. üì¶ Dynamic Import

**Definition:**
`import()` loads modules dynamically at runtime.

### ‚úÖ Key Points

* Returns a promise.
* Enables conditional/lazy loading.
* Used for code-splitting.

### Example

```js
if (condition) {
  const mod = await import("./math.js");
  mod.add(2, 3);
}
```

### üéØ Interview One-Liner

> ‚ÄúDynamic import lets you load modules at runtime. It returns a promise, enabling conditional and lazy loading.‚Äù

---

## 8. üéØ Logical Assignment Operators

**Definition:**
Shorthand operators for logical + assignment.

### ‚úÖ Key Points

* `||=` assigns if falsy.
* `&&=` assigns if truthy.
* `??=` assigns if null/undefined.

### Example

```js
let a = null;
a ||= 5;  // a = 5

let b = 0;
b ||= 5;  // b = 5
b ??= 5;  // b = 0 (unchanged)
```

### üéØ Interview One-Liner

> ‚ÄúLogical assignment operators (||=, &&=, ??=) combine short-circuiting with assignment. Handy for defaults and conditionals.‚Äù

---

## 9. üßæ Numeric Separators

**Definition:**
Underscores in numbers for readability.

### Example

```js
const big = 1_000_000_000;
console.log(big); // 1000000000
```

### üéØ Interview One-Liner

> ‚ÄúNumeric separators make large numbers readable, but don‚Äôt affect the value.‚Äù

---


# üü¶ Core JavaScript ‚Äî Expert-Level Revision

# üü¶ Patterns & Architecture in JavaScript

---

## 1. üì¶ Module Pattern

**Definition:**
Encapsulates private state using closures, exposing only a public API.

### ‚úÖ Key Points

* Common before ES6 modules (`import/export`).
* Uses IIFEs (Immediately Invoked Function Expressions).
* Prevents polluting global scope.

### Example

```js
const Counter = (function () {
  let count = 0; // private
  return {
    inc: () => ++count,
    get: () => count,
  };
})();
console.log(Counter.inc()); // 1
console.log(Counter.count); // undefined
```

### üéØ Interview One-Liner

> ‚ÄúThe module pattern hides implementation details with closures and exposes a controlled API. It was the precursor to ES modules.‚Äù

---

## 2. üëÅÔ∏è Observer Pattern

**Definition:**
One-to-many dependency: when subject changes, observers are notified.

### ‚úÖ Key Points

* Basis for event systems.
* Used in RxJS, MobX, DOM events.

### Example

```js
class Subject {
  constructor() { this.observers = []; }
  subscribe(fn) { this.observers.push(fn); }
  notify(data) { this.observers.forEach(fn => fn(data)); }
}
const subject = new Subject();
subject.subscribe(data => console.log("Got:", data));
subject.notify("Hello");
```

### üéØ Interview One-Liner

> ‚ÄúThe observer pattern lets many listeners react when one subject changes. It underlies events, RxJS, and reactive libraries.‚Äù

---

## 3. üì° Pub/Sub Pattern

**Definition:**
Decouples publishers from subscribers via a mediator (event bus).

### ‚úÖ Key Points

* Pub/Sub is like Observer but with a **broker** in between.
* Subscribers don‚Äôt know who published the event.

### Example

```js
const bus = {};
bus.events = {};
bus.subscribe = (event, fn) =>
  (bus.events[event] = (bus.events[event] || []).concat(fn));
bus.publish = (event, data) =>
  (bus.events[event] || []).forEach(fn => fn(data));

bus.subscribe("login", user => console.log("Welcome", user));
bus.publish("login", "Alice");
```

### üéØ Interview One-Liner

> ‚ÄúPub/Sub decouples producers and consumers with an event bus. Unlike Observer, subscribers don‚Äôt directly attach to the subject.‚Äù

---

## 4. üßë‚Äçü§ù‚Äçüßë Singleton Pattern

**Definition:**
Restricts a class/module to a single instance.

### ‚úÖ Key Points

* Common for global state, config, caches.
* Enforced via closures or static variables.

### Example

```js
class Singleton {
  constructor() {
    if (Singleton.instance) return Singleton.instance;
    Singleton.instance = this;
  }
}
const a = new Singleton();
const b = new Singleton();
console.log(a === b); // true
```

### üéØ Interview One-Liner

> ‚ÄúSingleton ensures one instance globally ‚Äî useful for config, caches, or logging, but overuse makes testing harder.‚Äù

---

## 5. üè≠ Factory Pattern

**Definition:**
Function/class that creates objects without exposing the creation logic.

### ‚úÖ Key Points

* Encapsulates instantiation.
* Can return different subclasses depending on arguments.

### Example

```js
function createUser(type) {
  if (type === "admin") return { role: "admin" };
  return { role: "guest" };
}
console.log(createUser("admin"));
```

### üéØ Interview One-Liner

> ‚ÄúFactory abstracts object creation, returning different variants without exposing constructor details.‚Äù

---

## 6. üß© Prototype Pattern

**Definition:**
Creates new objects by cloning existing ones.

### ‚úÖ Key Points

* In JS, all objects already inherit via prototypes.
* Object cloning often uses `Object.create(proto)`.

### Example

```js
const animal = { speak() { console.log("Hi"); } };
const dog = Object.create(animal);
dog.speak(); // "Hi"
```

### üéØ Interview One-Liner

> ‚ÄúPrototype pattern creates objects by cloning existing ones. In JavaScript, it‚Äôs built into the language via `Object.create`.‚Äù

---

## 7. üßÆ Functional Patterns (FP in JS)

### ‚úÖ Immutability

* Avoid mutating objects/arrays; use spread or `Object.assign`.

### ‚úÖ Function Composition

```js
const compose = (f, g) => x => f(g(x));
const double = x => x * 2;
const square = x => x * x;
console.log(compose(square, double)(3)); // (3*2)^2 = 36
```

### ‚úÖ Pipeline (proposed `|>` operator)

* More readable left-to-right function chaining.

### üéØ Interview One-Liner

> ‚ÄúFP patterns in JS emphasize immutability, pure functions, and composition. Composition allows small functions to build complex logic.‚Äù

---

## 8. ‚öñÔ∏è Strategy Pattern

**Definition:**
Encapsulates interchangeable algorithms behind a common interface.

### ‚úÖ Example

```js
class Payment {
  setStrategy(strategy) { this.strategy = strategy; }
  pay(amount) { this.strategy.pay(amount); }
}
class Paypal { pay(a) { console.log("PayPal:", a); } }
class Stripe { pay(a) { console.log("Stripe:", a); } }

const payment = new Payment();
payment.setStrategy(new Paypal());
payment.pay(100); // PayPal: 100
```

### üéØ Interview One-Liner

> ‚ÄúStrategy encapsulates interchangeable algorithms, letting you switch behaviors dynamically.‚Äù

---

## 9. üïµÔ∏è Decorator Pattern

**Definition:**
Adds functionality to objects without modifying them.

### ‚úÖ Key Points

* Popular in React (HOCs).
* In ES, decorator syntax (`@`) is in proposal stage.

### Example

```js
function withLogging(fn) {
  return (...args) => {
    console.log("Args:", args);
    return fn(...args);
  };
}
const sum = (a, b) => a + b;
const loggedSum = withLogging(sum);
loggedSum(2, 3); // Logs args
```

### üéØ Interview One-Liner

> ‚ÄúDecorator adds behavior to functions or objects without modifying the original ‚Äî e.g., React HOCs.‚Äù

---

## 10. üï∏Ô∏è Middleware Pattern

**Definition:**
Chain of functions where each step can process input and pass to next.

### ‚úÖ Key Points

* Popular in Express.js, Redux.
* Flexible for cross-cutting concerns (logging, auth).

### Example

```js
function compose(middleware) {
  return function (ctx) {
    let i = 0;
    function next() {
      const fn = middleware[i++];
      if (fn) fn(ctx, next);
    }
    next();
  };
}
const fn = compose([
  (ctx, next) => { ctx.push("a"); next(); },
  (ctx, next) => { ctx.push("b"); next(); }
]);
const arr = [];
fn(arr);
console.log(arr); // ["a","b"]
```

### üéØ Interview One-Liner

> ‚ÄúMiddleware composes a pipeline of functions where each can act and forward. Used in Express, Redux, Koa.‚Äù

---


# ‚úÖ Summary (Full Handbook)

This handbook covers expert-level JavaScript concepts in depth:

- Closures, Scope, Hoisting, `this`, Prototypes, Event Loop
- Asynchronous JavaScript (Timers, Promises, async/await, Generators, Debounce/Throttle, rAF, Workers)
- Advanced Objects & Memory (GC, Symbols, WeakMap/WeakSet, Descriptors, Proxy/Reflect, Immutability)
- Advanced Functions & ES6+ (HOFs, Currying, Modules, Destructuring, Params, Iterables, Map/Set, ES6+)
- Browser & DOM (Event Delegation, Reflow vs Repaint, DOM APIs, Storage, Security, Service Workers, CRP, Loading)
- Performance & Optimization (Leaks, Lazy Loading, Tree-shaking, Web Vitals, Async Scheduling, Bundling, Rendering)
- Advanced Types & Equality (Truthy/Falsy, == vs ===, NaN/-0, Object.is, Wrappers, typeof quirks, Coercion)
- Error Handling & Debugging (try/catch, Error types, Custom errors, Async handling, Global handlers, Debugging)
- Concurrency & Parallelism (Single-threaded model, Event Loop, Workers, SharedArrayBuffer, Node parallelism)
- ESNext & Modern Features (BigInt, Optional Chaining, Nullish, Top-level await, WeakRefs, Temporal, Imports, Operators)
- Patterns & Architecture (Module, Observer, Pub/Sub, Singleton, Factory, Prototype, FP, Strategy, Decorator, Middleware)
